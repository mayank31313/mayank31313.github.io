{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Scaleworks Introduction Welcome, I am excited to present Scaleworks ControlNet is a communication platform for devices like Raspberry Pi's that support python programming language. The purpose to build this platform is to connect various devices over a network(i.e private & public network). Each has a unique use-case. Control Net Architecture is divided in 3 Projects IOR Control Net Tower IOR Socket Server IOR Video Streamer Getting Started Server Setup Docker Docker is a open platform to run apps in a container and seperate those apps from the infrastructure. You can install docker as per your platform needs from here , we will also need Docker Compose which can be installed from this page . Download Docker Compose File cd ~ mkdir controlnet-docker cd controlnet-docker wget https://mayank31313.github.io/docker/full/docker-compose.yml The above command will download docker-compose file in the current directory Run servers in Docker To run containers just run the below command in the docker-compose file directory, it will pull necessary images and start docker containers. docker-compose up To stop the containers, run below command docker-compose down Client (IOR-Python) The client code is available on this github repository Setup Client For this example no external configuration is needed, all the settings are predefined. The below example will only give a use case on the controlnet platform. git clone https://github.com/mayank31313/ior-python cd ior-python/examples python3 LatencyCheck.py ../config/from.json ../config/to.json Usage config = { \"server\": \"localhost\", \"httpPort\": 5001, \"socketServer\": \"localhost\", \"tcpPort\": 8000, #\"useSSL\": True # Optional } Create Instance of IOT Client from ior_research.IOTClient import IOTClientWrapper iot = IOTClientWrpper(token=token, config = config) #Creating object for IOT Client Setting up Receive Function to do some Operation when a response is received. iot.set_on_receive(lambda x: print(x)) Last but not the least start the IOTClient iot.start() iot.join() Quick Demo","title":"Home"},{"location":"#welcome-to-scaleworks","text":"","title":"Welcome to Scaleworks"},{"location":"#introduction","text":"Welcome, I am excited to present Scaleworks ControlNet is a communication platform for devices like Raspberry Pi's that support python programming language. The purpose to build this platform is to connect various devices over a network(i.e private & public network). Each has a unique use-case. Control Net Architecture is divided in 3 Projects IOR Control Net Tower IOR Socket Server IOR Video Streamer","title":"Introduction"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#server","text":"","title":"Server"},{"location":"#setup-docker","text":"Docker is a open platform to run apps in a container and seperate those apps from the infrastructure. You can install docker as per your platform needs from here , we will also need Docker Compose which can be installed from this page .","title":"Setup Docker"},{"location":"#download-docker-compose-file","text":"cd ~ mkdir controlnet-docker cd controlnet-docker wget https://mayank31313.github.io/docker/full/docker-compose.yml The above command will download docker-compose file in the current directory","title":"Download Docker Compose File"},{"location":"#run-servers-in-docker","text":"To run containers just run the below command in the docker-compose file directory, it will pull necessary images and start docker containers. docker-compose up To stop the containers, run below command docker-compose down","title":"Run servers in Docker"},{"location":"#client-ior-python","text":"The client code is available on this github repository","title":"Client (IOR-Python)"},{"location":"#setup-client","text":"For this example no external configuration is needed, all the settings are predefined. The below example will only give a use case on the controlnet platform. git clone https://github.com/mayank31313/ior-python cd ior-python/examples python3 LatencyCheck.py ../config/from.json ../config/to.json","title":"Setup Client"},{"location":"#usage","text":"config = { \"server\": \"localhost\", \"httpPort\": 5001, \"socketServer\": \"localhost\", \"tcpPort\": 8000, #\"useSSL\": True # Optional }","title":"Usage"},{"location":"#create-instance-of-iot-client","text":"from ior_research.IOTClient import IOTClientWrapper iot = IOTClientWrpper(token=token, config = config) #Creating object for IOT Client","title":"Create Instance of IOT Client"},{"location":"#setting-up-receive-function-to-do-some-operation-when-a-response-is-received","text":"iot.set_on_receive(lambda x: print(x))","title":"Setting up Receive Function to do some Operation when a response is received."},{"location":"#last-but-not-the-least-start-the-iotclient","text":"iot.start() iot.join()","title":"Last but not the least start the IOTClient"},{"location":"#quick-demo","text":"","title":"Quick Demo"},{"location":"python-di/","text":"Python Dependency Injection Official Repo Introduction As the name suggest, this application is for injecting dependencies into other objects. It's much similar to Java Spring Framework. Show me the code Create a test bean class for custom dependency injection # Create a class for bean class TestBean: def __init__(self, name): self.name = name Define a bean method to return a Bean Object using @Bean. NOTE: : The bean method parameters and return type should have the class name of the dependent and return type object, to let it know which class object should be injected and returned. # Create a bean object for Autowiring @Bean() def getTestBean() -> TestBean: return TestBean(\"Test 123\") Test your dependency injection, using @Autowired. NOTE: : The autowired method parameters should have the class name of the Dependent Object, to let it know which class object should be injected. testBean = None # Autowire the dependency @Autowired() def setTestBean(bean: TestBean): global testBean print(bean) testBean = bean if __name__ == \"__main__\": app = AppInitilizer() # Create a instance for AppInitializer app.componentScan(\"test_module\") # Add package to scan for any component or bean app.run() # Call run methods to inject beans print(testBean.name) print(type(testBean)) Advance: Lookup at CNDI External yaml configurations Using cndi users can configure the application on different environemnt setting, using the rcn.profile attribute in the yaml file. Checkout the below yaml configuration rcn.profile: local mqtt: broker: localhost port: 1883 --- rcn.profile: dev mqtt: broker: dev_mqtt_adderss.com port: 11883 The above yaml has the configurations for two environment local and dev , with different configuration for mqtt brokers. Below is the code for how to use it. from cndi.env import loadEnvFromFile, getContextEnvironment # First step: set the profile, this can be set directly to environment RCN_ENVS_CONFIG.active.profile or using os package RCN_ENVS_CONFIG = 'RCN_ENVS_CONFIG' os.environ[f\"{RCN_ENVS_CONFIG}.active.profile\"] = \"local\" # Set profile to use # Load yaml file loadEnvFromFile(\"path/to/yaml\") server = getContextEnvironment(\"mqtt.broker\") # Get Property Value port = int(getContextEnvironment(\"mqtt.port\")) # Get Property Value Flask Application Let's create a flask app to get the working on CNDI in depth (well below video doesn't go that far but gives some understanding). In this example we will create a Flask app which will listen at /events. Find the repository here. NOTE: : The above app requires a mqtt broker running in background. Otherwise it will throw exception while calling connect method. Route: /event will send a timestamp to mqtt topic defined in the # Directory Structure src/ + ./beans/*/*.py -> Define beans in this modules and sub modules. + ./app.py -> Main application. + ./configurations/*.yml -> YAML files to define external configurations. Implementation of CNDI","title":"Quick Start"},{"location":"python-di/#python-dependency-injection","text":"Official Repo","title":"Python Dependency Injection"},{"location":"python-di/#introduction","text":"As the name suggest, this application is for injecting dependencies into other objects. It's much similar to Java Spring Framework.","title":"Introduction"},{"location":"python-di/#show-me-the-code","text":"Create a test bean class for custom dependency injection # Create a class for bean class TestBean: def __init__(self, name): self.name = name Define a bean method to return a Bean Object using @Bean. NOTE: : The bean method parameters and return type should have the class name of the dependent and return type object, to let it know which class object should be injected and returned. # Create a bean object for Autowiring @Bean() def getTestBean() -> TestBean: return TestBean(\"Test 123\") Test your dependency injection, using @Autowired. NOTE: : The autowired method parameters should have the class name of the Dependent Object, to let it know which class object should be injected. testBean = None # Autowire the dependency @Autowired() def setTestBean(bean: TestBean): global testBean print(bean) testBean = bean if __name__ == \"__main__\": app = AppInitilizer() # Create a instance for AppInitializer app.componentScan(\"test_module\") # Add package to scan for any component or bean app.run() # Call run methods to inject beans print(testBean.name) print(type(testBean))","title":"Show me the code"},{"location":"python-di/#advance-lookup-at-cndi","text":"","title":"Advance: Lookup at CNDI"},{"location":"python-di/#external-yaml-configurations","text":"Using cndi users can configure the application on different environemnt setting, using the rcn.profile attribute in the yaml file. Checkout the below yaml configuration rcn.profile: local mqtt: broker: localhost port: 1883 --- rcn.profile: dev mqtt: broker: dev_mqtt_adderss.com port: 11883 The above yaml has the configurations for two environment local and dev , with different configuration for mqtt brokers. Below is the code for how to use it. from cndi.env import loadEnvFromFile, getContextEnvironment # First step: set the profile, this can be set directly to environment RCN_ENVS_CONFIG.active.profile or using os package RCN_ENVS_CONFIG = 'RCN_ENVS_CONFIG' os.environ[f\"{RCN_ENVS_CONFIG}.active.profile\"] = \"local\" # Set profile to use # Load yaml file loadEnvFromFile(\"path/to/yaml\") server = getContextEnvironment(\"mqtt.broker\") # Get Property Value port = int(getContextEnvironment(\"mqtt.port\")) # Get Property Value","title":"External yaml configurations"},{"location":"python-di/#flask-application","text":"Let's create a flask app to get the working on CNDI in depth (well below video doesn't go that far but gives some understanding). In this example we will create a Flask app which will listen at /events. Find the repository here. NOTE: : The above app requires a mqtt broker running in background. Otherwise it will throw exception while calling connect method. Route: /event will send a timestamp to mqtt topic defined in the # Directory Structure src/ + ./beans/*/*.py -> Define beans in this modules and sub modules. + ./app.py -> Main application. + ./configurations/*.yml -> YAML files to define external configurations.","title":"Flask Application"},{"location":"python-di/#implementation-of-cndi","text":"","title":"Implementation of CNDI"},{"location":"python-di/binders/","text":"Binders Introduction Now lets start the advance understanding for the cndi, with the quick start guide we saw how to use Autowired annotations and initialize a global bean object. It this part we will take a look at binders and Message brokers. The binders are actually used to bind a topic to a channel, so let's take an example of a Pub/Sub Message Broker, where we have a Publisher and a Subscriber. A publisher will publish a message to 'xyz' topic, a Subscriber will subscribe to 'xyz' topic and will receive any event data publish to that topic. This is how a messaging system work in a high level overview. Now so let's say we have a message broker, a publisher and a subscriber that subscribe to a topic[s] in a normal architecture we create an instance for publisher and subscriber that connects to message broker and boom we have our messaging system app. But take a scenario where we have to deal with multiple message broker servers, (i.e. mqtt, rabbit etc) we might need to manually take care of publishers/subscribers, to resolve this problem we add a layer in the pub/sub architecture and the layer is called Binder . Message Binder and Message/Subscriber Channel To use message binder we need a message channel, a message channel can a alphabetic string that binds a topic. Syntax rcn.binders.message.mqtt.<producer|consumer>.<channelName>.destination = <topic-name> Implementation To implement Binders in the Application we need to use MessageChannel/SubscriberChannel class, MessageChannel is for producer/publisher and SubscriberChannel is for consumer/subscriber. The default configuration properties that need to be added in the yaml configuration are below rcn.binders.message.enable: Enables the DefaultMessageBinder rcn.binders.message.default: The property which describes the message broker to use currently only mqtt is supported rcn.binders.message.brokerUrl: ip address to broker rcn.binders.message.brokerPort: port of the broker to connect The yaml properties looks like: rcn: binders: message: enable: true default: mqtt brokerUrl: localhost brokerPort: 1883 Create Producer/Publisher Let's create Producer using message binder, using @Output decoration we can create a MessageChannel instance that automatically configures a channel to the topic. The only thing to produce a message is to call send method from MessageChannel @Component class Source: outputChannel1Binding: MessageChannel @Output(\"<channel-name>\") def setOutputForDefaultChannel(self, messageBinder: MqttProducerBinding): self.outputChannel1Binding = messageBinder # Create App Initializer appInitializer = AppInitializer() appInitializer.componentScan(\"\") appInitializer.run() # YAML Configuration rcn: binders: message: mqtt: producer: <channel-name>: destination: <topic> Create Subscriber/Consumer Let's create Consumer using message binder, using @Input decoration we can create a SubscriberChannel instance that automatically configures a channel to the topic. The simple consumer looks like the below code @Input(\"<channel-name>\") def setInputForDefaultChannel(message): print(message) # YAML Configuration rcn: binders: message: mqtt: consumer: <channel-name>: destination: <topic>","title":"Binders"},{"location":"python-di/binders/#binders","text":"","title":"Binders"},{"location":"python-di/binders/#introduction","text":"Now lets start the advance understanding for the cndi, with the quick start guide we saw how to use Autowired annotations and initialize a global bean object. It this part we will take a look at binders and Message brokers. The binders are actually used to bind a topic to a channel, so let's take an example of a Pub/Sub Message Broker, where we have a Publisher and a Subscriber. A publisher will publish a message to 'xyz' topic, a Subscriber will subscribe to 'xyz' topic and will receive any event data publish to that topic. This is how a messaging system work in a high level overview. Now so let's say we have a message broker, a publisher and a subscriber that subscribe to a topic[s] in a normal architecture we create an instance for publisher and subscriber that connects to message broker and boom we have our messaging system app. But take a scenario where we have to deal with multiple message broker servers, (i.e. mqtt, rabbit etc) we might need to manually take care of publishers/subscribers, to resolve this problem we add a layer in the pub/sub architecture and the layer is called Binder .","title":"Introduction"},{"location":"python-di/binders/#message-binder-and-messagesubscriber-channel","text":"To use message binder we need a message channel, a message channel can a alphabetic string that binds a topic.","title":"Message Binder and Message/Subscriber Channel"},{"location":"python-di/binders/#syntax","text":"rcn.binders.message.mqtt.<producer|consumer>.<channelName>.destination = <topic-name>","title":"Syntax"},{"location":"python-di/binders/#implementation","text":"To implement Binders in the Application we need to use MessageChannel/SubscriberChannel class, MessageChannel is for producer/publisher and SubscriberChannel is for consumer/subscriber. The default configuration properties that need to be added in the yaml configuration are below rcn.binders.message.enable: Enables the DefaultMessageBinder rcn.binders.message.default: The property which describes the message broker to use currently only mqtt is supported rcn.binders.message.brokerUrl: ip address to broker rcn.binders.message.brokerPort: port of the broker to connect The yaml properties looks like: rcn: binders: message: enable: true default: mqtt brokerUrl: localhost brokerPort: 1883","title":"Implementation"},{"location":"python-di/binders/#create-producerpublisher","text":"Let's create Producer using message binder, using @Output decoration we can create a MessageChannel instance that automatically configures a channel to the topic. The only thing to produce a message is to call send method from MessageChannel @Component class Source: outputChannel1Binding: MessageChannel @Output(\"<channel-name>\") def setOutputForDefaultChannel(self, messageBinder: MqttProducerBinding): self.outputChannel1Binding = messageBinder # Create App Initializer appInitializer = AppInitializer() appInitializer.componentScan(\"\") appInitializer.run() # YAML Configuration rcn: binders: message: mqtt: producer: <channel-name>: destination: <topic>","title":"Create Producer/Publisher"},{"location":"python-di/binders/#create-subscriberconsumer","text":"Let's create Consumer using message binder, using @Input decoration we can create a SubscriberChannel instance that automatically configures a channel to the topic. The simple consumer looks like the below code @Input(\"<channel-name>\") def setInputForDefaultChannel(message): print(message) # YAML Configuration rcn: binders: message: mqtt: consumer: <channel-name>: destination: <topic>","title":"Create Subscriber/Consumer"},{"location":"python-di/decorators/","text":"Advance Decorators Conditional Rendering @ConditionalRendering decorator is used when a Component has to be initialized with some condition. Just simple like an if-else condition if callback condition is satisfied else the component will not be loaded with Application Initializer. Conditional Rendering Component is loaded only when callback condition returns true, or else the component will not load. Example Below snippet is an example of a Condition Rendered Component, TestConditionalAnnotation will only initialise if TEST key is available in environment variables (i.e. os.environ), Similarly TestNotConditionRendering will be loaded when TEST is not available in environment variables. @Component @ConditionalRendering(callback=lambda x: \"TEST\" in os.environ) class TestConditionalAnnotation: def __init__(self): # Do some stuff print(\"TestConditionalAnnotation Initialized\") def postConstruct(self): # Do some stuff print(\"Called Post Construct\") @Component @ConditionalRendering(callback=lambda x: \"TEST\" not in os.environ) class TestNotConditionRendering: def __init__(self): # Do some stuff print(\"TestNotConditionRendering Initialised\") Profiler Based Component @Profile decorator expects a list of profile names as String object, if not passed profile will fallback to default profile, in other words Profile decorator is Conditional Rendering where it checks for specific Profile setup Note To use Profile decorator make sure RCN_ENVS_CONFIG.active.profile is set in environment variable before starting the script, otherwise a default profile will be used Example Below snippet is an example of how to use Profile decorator, LoadDefaultProfile Class is a default profile class which will be loaded when RCN_ENVS_CONFIG.active.profile is not set or value is default . Similarly, LoadDevProfile Class is has a profiler to initialize only when profile is set to dev . @Component @Profile() # when RCN_ENVS_CONFIG.active.profile=default or not set class LoadDefaultProfile: def __init__(self): # Do some stuff print(\"Default Profile Component Loaded\") @Component @Profile(profiles=['dev']) # when RCN_ENVS_CONFIG.active.profile=dev class LoadDevProfile: # Do some stuff def __init__(self): print(\"Dev Profile Component Loaded\")","title":"Other Decorators"},{"location":"python-di/decorators/#advance-decorators","text":"","title":"Advance Decorators"},{"location":"python-di/decorators/#conditional-rendering","text":"@ConditionalRendering decorator is used when a Component has to be initialized with some condition. Just simple like an if-else condition if callback condition is satisfied else the component will not be loaded with Application Initializer. Conditional Rendering Component is loaded only when callback condition returns true, or else the component will not load.","title":"Conditional Rendering"},{"location":"python-di/decorators/#example","text":"Below snippet is an example of a Condition Rendered Component, TestConditionalAnnotation will only initialise if TEST key is available in environment variables (i.e. os.environ), Similarly TestNotConditionRendering will be loaded when TEST is not available in environment variables. @Component @ConditionalRendering(callback=lambda x: \"TEST\" in os.environ) class TestConditionalAnnotation: def __init__(self): # Do some stuff print(\"TestConditionalAnnotation Initialized\") def postConstruct(self): # Do some stuff print(\"Called Post Construct\") @Component @ConditionalRendering(callback=lambda x: \"TEST\" not in os.environ) class TestNotConditionRendering: def __init__(self): # Do some stuff print(\"TestNotConditionRendering Initialised\")","title":"Example"},{"location":"python-di/decorators/#profiler-based-component","text":"@Profile decorator expects a list of profile names as String object, if not passed profile will fallback to default profile, in other words Profile decorator is Conditional Rendering where it checks for specific Profile setup","title":"Profiler Based Component"},{"location":"python-di/decorators/#note","text":"To use Profile decorator make sure RCN_ENVS_CONFIG.active.profile is set in environment variable before starting the script, otherwise a default profile will be used","title":"Note"},{"location":"python-di/decorators/#example_1","text":"Below snippet is an example of how to use Profile decorator, LoadDefaultProfile Class is a default profile class which will be loaded when RCN_ENVS_CONFIG.active.profile is not set or value is default . Similarly, LoadDevProfile Class is has a profiler to initialize only when profile is set to dev . @Component @Profile() # when RCN_ENVS_CONFIG.active.profile=default or not set class LoadDefaultProfile: def __init__(self): # Do some stuff print(\"Default Profile Component Loaded\") @Component @Profile(profiles=['dev']) # when RCN_ENVS_CONFIG.active.profile=dev class LoadDevProfile: # Do some stuff def __init__(self): print(\"Dev Profile Component Loaded\")","title":"Example"},{"location":"python-di/events/","text":"Events API RCN Events API is a thread based watching for events to occur, it automatically takes care for calling the handler when a event is triggered. It requires two methods an invoker and a handler. Note The events API is available in version >= 2.1.1 for cndi Invoker Method Invoker method decides weather to call a event handler or not, It's that simple this method is a custom method and should return a dict object containing a key trigger a boolean, if it returns true the event is triggered otherwise it's not. { trigger: booleanValue, otherAttributes... } Handler Method Handler Method is the method which takes care of an event when its triggered. Code Invoker Method: As discussed above the invoker method will decide if a event should be triggered or not. Below we will define a invoker method that will trigger event every time it's called def invokerMethod(eventObject): return dict(trigger=True) Here we are return trigger as true, so it will trigger event everytime we can manage the event triggering through this. Handler Method Below is a event handler method with two arguments, the first argument is the dictObject that we returned from the InvokerMethod , the second object is the interesting one this is the same object we are pass as single object in invoker method. Lets have a look when we create an EventObject below. def handle(callEvent, eventObject): # do something pass Register Event Let's check how to register a event into context. # Event Object event = Event(event_name=\"testing_event\", # Event Name event_handler=handle, # Set Handler Method event_object=dict(informativeData=\"hello\"), # Set Initial EventData event_invoker=invokerMethod) # Set Handler Method # Create a Event Handler object # Note: The event handler should be invoked as a cndi component, rather initializing it manually eventHandler = EventHandler() eventHandler.registerEvent(event=event) # Start Event Handler eventHandler.start() Configuration Properties The below keys should be prefixed with rcn.events. in order to work with events api. Key Default Value Description enable False Enables Events API waittime 2.0 sec The time to wait for event cycle to call invoker method expected.invoker.time 3 millis The expected time for invoker method to run, exceding the expected time will result in raising a warning log","title":"Events API"},{"location":"python-di/events/#events-api","text":"RCN Events API is a thread based watching for events to occur, it automatically takes care for calling the handler when a event is triggered. It requires two methods an invoker and a handler. Note The events API is available in version >= 2.1.1 for cndi","title":"Events API"},{"location":"python-di/events/#invoker-method","text":"Invoker method decides weather to call a event handler or not, It's that simple this method is a custom method and should return a dict object containing a key trigger a boolean, if it returns true the event is triggered otherwise it's not. { trigger: booleanValue, otherAttributes... }","title":"Invoker Method"},{"location":"python-di/events/#handler-method","text":"Handler Method is the method which takes care of an event when its triggered.","title":"Handler Method"},{"location":"python-di/events/#code","text":"","title":"Code"},{"location":"python-di/events/#invoker-method_1","text":"As discussed above the invoker method will decide if a event should be triggered or not. Below we will define a invoker method that will trigger event every time it's called def invokerMethod(eventObject): return dict(trigger=True) Here we are return trigger as true, so it will trigger event everytime we can manage the event triggering through this.","title":"Invoker Method:"},{"location":"python-di/events/#handler-method_1","text":"Below is a event handler method with two arguments, the first argument is the dictObject that we returned from the InvokerMethod , the second object is the interesting one this is the same object we are pass as single object in invoker method. Lets have a look when we create an EventObject below. def handle(callEvent, eventObject): # do something pass","title":"Handler Method"},{"location":"python-di/events/#register-event","text":"Let's check how to register a event into context. # Event Object event = Event(event_name=\"testing_event\", # Event Name event_handler=handle, # Set Handler Method event_object=dict(informativeData=\"hello\"), # Set Initial EventData event_invoker=invokerMethod) # Set Handler Method # Create a Event Handler object # Note: The event handler should be invoked as a cndi component, rather initializing it manually eventHandler = EventHandler() eventHandler.registerEvent(event=event) # Start Event Handler eventHandler.start()","title":"Register Event"},{"location":"python-di/events/#configuration-properties","text":"The below keys should be prefixed with rcn.events. in order to work with events api. Key Default Value Description enable False Enables Events API waittime 2.0 sec The time to wait for event cycle to call invoker method expected.invoker.time 3 millis The expected time for invoker method to run, exceding the expected time will result in raising a warning log","title":"Configuration Properties"},{"location":"python-di/features/","text":"Use Case In simple words IoC is giving your program a part a flow of control using a framework, for python it's here these helps to configure the application in multiple ways below are few examples of this Decorators Decorators are the way to invoke IoC with your application in python, common decorators we can use are @Bean , @Component and @Autowired these decorators can be used to configure and control most of the part of your code. @Bean @Bean is used in a method adding Bean decorator on a method automatically creates a lifecycle and automatic initialization of the bean in the App Context Below example demonstrate a Bean method that returns a Class Object of type TestBean Class. @Bean() # Bean Decorator def getTestBean() -> TestBean: # Return Type is required to be specified return TestBean(\"Test 123\") # Bean Object @Component @Component is used to automatically initialize a class object into App Context, this decorator is only used on Class types. Below example shows a normal class as a component class in python @Component # Component Decorator class TestComponentAnnotation: def __init__(self): print(\"Initialized\") Autowired @Autowired is used to inject loaded beans and components into user defined object this requires a setter method to inject to object @Autowired() # Autowired Decorator def setConfig(bean: TestBean, component: TestComponentAnnotation): # Parameter Type is required global testBean, testComponent testBean = bean testComponent = component How to Initialize IoC AppInitializer class is responsible to handle bindings and for Dependency Injection it controls the bean initialization and bean context until all the beans/components are injected. Below two lines are the easiest lines to invoke dependency inject in your application app = AppInitializer() # Create AppInitializer object app.run() # Invoke Dependency Injection and Binding Configs","title":"Features"},{"location":"python-di/features/#use-case","text":"In simple words IoC is giving your program a part a flow of control using a framework, for python it's here these helps to configure the application in multiple ways below are few examples of this","title":"Use Case"},{"location":"python-di/features/#decorators","text":"Decorators are the way to invoke IoC with your application in python, common decorators we can use are @Bean , @Component and @Autowired these decorators can be used to configure and control most of the part of your code.","title":"Decorators"},{"location":"python-di/features/#bean","text":"@Bean is used in a method adding Bean decorator on a method automatically creates a lifecycle and automatic initialization of the bean in the App Context Below example demonstrate a Bean method that returns a Class Object of type TestBean Class. @Bean() # Bean Decorator def getTestBean() -> TestBean: # Return Type is required to be specified return TestBean(\"Test 123\") # Bean Object","title":"@Bean"},{"location":"python-di/features/#component","text":"@Component is used to automatically initialize a class object into App Context, this decorator is only used on Class types. Below example shows a normal class as a component class in python @Component # Component Decorator class TestComponentAnnotation: def __init__(self): print(\"Initialized\")","title":"@Component"},{"location":"python-di/features/#autowired","text":"@Autowired is used to inject loaded beans and components into user defined object this requires a setter method to inject to object @Autowired() # Autowired Decorator def setConfig(bean: TestBean, component: TestComponentAnnotation): # Parameter Type is required global testBean, testComponent testBean = bean testComponent = component","title":"Autowired"},{"location":"python-di/features/#how-to-initialize-ioc","text":"AppInitializer class is responsible to handle bindings and for Dependency Injection it controls the bean initialization and bean context until all the beans/components are injected. Below two lines are the easiest lines to invoke dependency inject in your application app = AppInitializer() # Create AppInitializer object app.run() # Invoke Dependency Injection and Binding Configs","title":"How to Initialize IoC"},{"location":"rcn/","text":"Scaleworks CLI Scaleworks CLI is a command line utility that help to configure multiple profile configuration. Installation The installation is quick and direct, just run either of below command. pip3 install -U rcn pip3 install git+https://github.com/mayank31313/rcn-cli Commands configure command is for the first time setup to configure a profile. Below is the following usage. When configure command is supplied it takes this inputs. While running this command it also expects an optional argument as --profile profile_name if not passed it will consider profile as \"default\" profile. Keycloak Server URL (For ex. http[s]://[server]:[port]/realms/ControlNet/protocol) Client ID Username and Password Once all the inputs are passed, the cli tool will hit the keycloak server for the token and store it in ${HOME}/.rcn/[profile].yml rcn configure [--profile [profile_name]] login command updates the user credentials in the [profile].yml file rcn login [--profile [profile_name]]","title":"Overview"},{"location":"rcn/#scaleworks-cli","text":"Scaleworks CLI is a command line utility that help to configure multiple profile configuration.","title":"Scaleworks CLI"},{"location":"rcn/#installation","text":"The installation is quick and direct, just run either of below command. pip3 install -U rcn pip3 install git+https://github.com/mayank31313/rcn-cli","title":"Installation"},{"location":"rcn/#commands","text":"","title":"Commands"},{"location":"rcn/#configure","text":"command is for the first time setup to configure a profile. Below is the following usage. When configure command is supplied it takes this inputs. While running this command it also expects an optional argument as --profile profile_name if not passed it will consider profile as \"default\" profile. Keycloak Server URL (For ex. http[s]://[server]:[port]/realms/ControlNet/protocol) Client ID Username and Password Once all the inputs are passed, the cli tool will hit the keycloak server for the token and store it in ${HOME}/.rcn/[profile].yml rcn configure [--profile [profile_name]]","title":"configure"},{"location":"rcn/#login","text":"command updates the user credentials in the [profile].yml file rcn login [--profile [profile_name]]","title":"login"},{"location":"rcn/entities/","text":"Scaleworks Entities An ecosystem of multiple applications combined together to form a combined together form a Hive Mind. Those entities are listed below as a Server side and Client side. Client Side Sender / Pusher: Service used as a transmitter or remote to control the vehicle Receiver / Puller: Service used to receiver all the messages and push to the configured mqtt topic (defaults to rcn.robot.drone.messages ) Message Splitter: Service responsible for splitting the messages into multiple topics as one to many topics. Mqtt To Channel: Service responsible to pull the input values and write the desired PWM values to the output controller. GPIO Controller: Service responsible for controlling the gpio pin state. State Persistor: Service responsible to sync the vehicle state and store in local database. Dronekit Connector: Service responsible for the updating the states and keep data in sync with the internal mqtt topics and services. Receiver / Puller The Receiver service pulls the data from IOR Server and publishes to the internal mqtt topic so that the data can be consumed by appropriate subscribers. The Topic configuration for the service is below. The other task for the service is to keep sync of the device/vehicle state in sync with the ior servers. Thus the services also subscribes to inbound message mqtt topic. RCN Outbound Topic - rcn.robot.drone.messages RCN Inbound Topic - rcn.elfie.ior.messages Message Splitter As described above the service is responsible for splitting the messages produced by the receiver service to their appropriate messaging channels.","title":"Entities"},{"location":"rcn/entities/#scaleworks-entities","text":"An ecosystem of multiple applications combined together to form a combined together form a Hive Mind. Those entities are listed below as a Server side and Client side.","title":"Scaleworks Entities"},{"location":"rcn/entities/#client-side","text":"Sender / Pusher: Service used as a transmitter or remote to control the vehicle Receiver / Puller: Service used to receiver all the messages and push to the configured mqtt topic (defaults to rcn.robot.drone.messages ) Message Splitter: Service responsible for splitting the messages into multiple topics as one to many topics. Mqtt To Channel: Service responsible to pull the input values and write the desired PWM values to the output controller. GPIO Controller: Service responsible for controlling the gpio pin state. State Persistor: Service responsible to sync the vehicle state and store in local database. Dronekit Connector: Service responsible for the updating the states and keep data in sync with the internal mqtt topics and services.","title":"Client Side"},{"location":"rcn/entities/#receiver-puller","text":"The Receiver service pulls the data from IOR Server and publishes to the internal mqtt topic so that the data can be consumed by appropriate subscribers. The Topic configuration for the service is below. The other task for the service is to keep sync of the device/vehicle state in sync with the ior servers. Thus the services also subscribes to inbound message mqtt topic. RCN Outbound Topic - rcn.robot.drone.messages RCN Inbound Topic - rcn.elfie.ior.messages","title":"Receiver / Puller"},{"location":"rcn/entities/#message-splitter","text":"As described above the service is responsible for splitting the messages produced by the receiver service to their appropriate messaging channels.","title":"Message Splitter"},{"location":"user_guide/client/","text":"Client Configuration To be known words Device A unique ior-client process, that runs on the client device. These devices are seperated by unique device code in the given user context. Connection A connection is connectivity bridge between 2 clients, managed by the IOR-SocketServer. Before the target devices connect to server, a connection has be specified on the server side to get it to work. Connection Config After cloning this repository , the directory structure is a follows ./ior-python /config /from.json /from2.json /to.json /to2.json /iorConfigs.config These are the client connection config that are required by every client that connects to the IOR-SocketServer, and are very important. These files contains server and client related configs. These files can also be downloaded through Controlnet Frontend from connections section. But by default, these configuration files can be used to Quick Start the client application. Other than that iotConfig.config file is not the connection configuration, but has some external configuration that can be used by IOR Client. Lets go In this section we will create a and understand, how the connectivity and connection works in a device. When a socket server instance is created, it also creates a default user at the server side along with some devices and connections listed below: Device 1 - Master 1 (type = Raspberry Pi) Device 2 - Slave 1 (type = Raspberry Pi) Device 3 - Master 2 (type = Raspberry Pi) Device 4 - Slave 2 (type = Raspberry Pi) Master 1,2 and Slave 1,2 are just device name given, it doesn't mean that the only master can control the slave. The communication is bidirectional. After creating a device, the devices will not pair up to each other automatically, we will need to specify a connection between those. See below image. There are 2 connections already created Connection 1: Master 1 <--> Slave 1 Connection 2: Master 2 <--> Slave 2 After creating a connection, users can download the configuration file for each connecting device from the download button. These are required and important file, as they store client configurations. In the above section , we specified json files, these are the same connection file which store client configuration. from.json = Master 1 to.json = Slave 1 from.json = Master 2 to.json = Slave 2 These json files also help socket-server to authenticate. Events and Watchers Events and Watchers are thread based operations, watchers invoke certain events those are configure in IOR Client, to check the big picture check here a predefined event amd watcher is already present in ior client which watches the latest message read time to check for any error in realtime application. But it's not enabled by default below properties needs to be configured in order to use it. NOTE: This properties are required before using the MessageWatcher The below keys should be prefixed with rcn.ior.client. in order to work with events api. Key Default Value Description events.delay.exceeded.name trigger.iorClient.delay.exceeded The name of the event to call if the difference between last message and current exceeded to use it the event should be already registered using EventHandler class expected.delay 0.5 sec The time difference in seconds to accept for certain amount of delay in messages Code Snippet @Bean() def getEventHandler() -> EventHandler: eventHandler = EventHandler() eventHandler.start() eventHandler.registerEvent(Event(getContextEnvironment(\"events.delay.exceeded.name\"), lambda triggerData,_: print(triggerData))) return eventHandler After creating a EventHandler object we just need to register an event to the application context, whenever the watcher detects a more time difference than specified it will trigger the event. Whats Next There is more content to add.","title":"Client"},{"location":"user_guide/client/#client-configuration","text":"","title":"Client Configuration"},{"location":"user_guide/client/#to-be-known-words","text":"","title":"To be known words"},{"location":"user_guide/client/#device","text":"A unique ior-client process, that runs on the client device. These devices are seperated by unique device code in the given user context.","title":"Device"},{"location":"user_guide/client/#connection","text":"A connection is connectivity bridge between 2 clients, managed by the IOR-SocketServer. Before the target devices connect to server, a connection has be specified on the server side to get it to work.","title":"Connection"},{"location":"user_guide/client/#connection-config","text":"After cloning this repository , the directory structure is a follows ./ior-python /config /from.json /from2.json /to.json /to2.json /iorConfigs.config These are the client connection config that are required by every client that connects to the IOR-SocketServer, and are very important. These files contains server and client related configs. These files can also be downloaded through Controlnet Frontend from connections section. But by default, these configuration files can be used to Quick Start the client application. Other than that iotConfig.config file is not the connection configuration, but has some external configuration that can be used by IOR Client.","title":"Connection Config"},{"location":"user_guide/client/#lets-go","text":"In this section we will create a and understand, how the connectivity and connection works in a device. When a socket server instance is created, it also creates a default user at the server side along with some devices and connections listed below: Device 1 - Master 1 (type = Raspberry Pi) Device 2 - Slave 1 (type = Raspberry Pi) Device 3 - Master 2 (type = Raspberry Pi) Device 4 - Slave 2 (type = Raspberry Pi) Master 1,2 and Slave 1,2 are just device name given, it doesn't mean that the only master can control the slave. The communication is bidirectional. After creating a device, the devices will not pair up to each other automatically, we will need to specify a connection between those. See below image. There are 2 connections already created Connection 1: Master 1 <--> Slave 1 Connection 2: Master 2 <--> Slave 2 After creating a connection, users can download the configuration file for each connecting device from the download button. These are required and important file, as they store client configurations. In the above section , we specified json files, these are the same connection file which store client configuration. from.json = Master 1 to.json = Slave 1 from.json = Master 2 to.json = Slave 2 These json files also help socket-server to authenticate.","title":"Lets go"},{"location":"user_guide/client/#events-and-watchers","text":"Events and Watchers are thread based operations, watchers invoke certain events those are configure in IOR Client, to check the big picture check here a predefined event amd watcher is already present in ior client which watches the latest message read time to check for any error in realtime application. But it's not enabled by default below properties needs to be configured in order to use it. NOTE: This properties are required before using the MessageWatcher The below keys should be prefixed with rcn.ior.client. in order to work with events api. Key Default Value Description events.delay.exceeded.name trigger.iorClient.delay.exceeded The name of the event to call if the difference between last message and current exceeded to use it the event should be already registered using EventHandler class expected.delay 0.5 sec The time difference in seconds to accept for certain amount of delay in messages","title":"Events and Watchers"},{"location":"user_guide/client/#code-snippet","text":"@Bean() def getEventHandler() -> EventHandler: eventHandler = EventHandler() eventHandler.start() eventHandler.registerEvent(Event(getContextEnvironment(\"events.delay.exceeded.name\"), lambda triggerData,_: print(triggerData))) return eventHandler After creating a EventHandler object we just need to register an event to the application context, whenever the watcher detects a more time difference than specified it will trigger the event.","title":"Code Snippet"},{"location":"user_guide/client/#whats-next","text":"There is more content to add.","title":"Whats Next"},{"location":"user_guide/docker-setup/","text":"Docker Setup","title":"Docker setup"},{"location":"user_guide/docker-setup/#docker-setup","text":"","title":"Docker Setup"},{"location":"user_guide/examples/","text":"IOR Client Examples Client Dependencies CNDI >= 2.1.1 docs Paho MQTT requests pick==1.2.0 ruamel.yaml==0.17.21","title":"Client Example"},{"location":"user_guide/examples/#ior-client-examples","text":"","title":"IOR Client Examples"},{"location":"user_guide/examples/#client-dependencies","text":"CNDI >= 2.1.1 docs Paho MQTT requests pick==1.2.0 ruamel.yaml==0.17.21","title":"Client Dependencies"},{"location":"user_guide/server/","text":"Server Setup and Configuration As discuss on this page , control net depends upon 3 Application. On this page we will discuss those 3 Apps in detail. The Application Servers Control Net Tower The Server handles all the REST API requests which deals with User, Devices and Connections. The Authentication used is JWT Token Authentication. Using the server api, we can manage user, client and connections. Click here for Docker Image Socket Server (Tunnel Server) This server uses TCP Sockets to communicate. The server connects client across each other. The server is also responsible for handling the socket message. It uses AES Encryption with the Connection Key, but is partially encrypted means the messages are decrypted at the server side. But this limitation will be removed in the future builds. Click here for Docker Image Video Streamer This server is used create a Video Live Stream from a device to end user, it uses WebRTC behind the scenes. Connecting to the server requires JWT Token which can be created through Control Net Tower and the stream can be watch on the Control Net Frontend -> Sign In -> Video Streaming (On Left Drawer), for current build you can stream only 1 Device at a time. Click here for Docker Image RCN Drone Backend This service specifically created to consumer drone realtime data and processing the attributes like altitude, velocity, location etc. Currently, the service in under development. The data will be used export in metric operators like prometheus and create dashboards. Additional Features The Streamer can also be used for Computer Vision and Machine Learning can be also implemented. Users can implement CNN architecture as per the use case.","title":"Server"},{"location":"user_guide/server/#server-setup-and-configuration","text":"As discuss on this page , control net depends upon 3 Application. On this page we will discuss those 3 Apps in detail.","title":"Server Setup and Configuration"},{"location":"user_guide/server/#the-application-servers","text":"","title":"The Application Servers"},{"location":"user_guide/server/#control-net-tower","text":"The Server handles all the REST API requests which deals with User, Devices and Connections. The Authentication used is JWT Token Authentication. Using the server api, we can manage user, client and connections. Click here for Docker Image","title":"Control Net Tower"},{"location":"user_guide/server/#socket-server-tunnel-server","text":"This server uses TCP Sockets to communicate. The server connects client across each other. The server is also responsible for handling the socket message. It uses AES Encryption with the Connection Key, but is partially encrypted means the messages are decrypted at the server side. But this limitation will be removed in the future builds. Click here for Docker Image","title":"Socket Server (Tunnel Server)"},{"location":"user_guide/server/#video-streamer","text":"This server is used create a Video Live Stream from a device to end user, it uses WebRTC behind the scenes. Connecting to the server requires JWT Token which can be created through Control Net Tower and the stream can be watch on the Control Net Frontend -> Sign In -> Video Streaming (On Left Drawer), for current build you can stream only 1 Device at a time. Click here for Docker Image","title":"Video Streamer"},{"location":"user_guide/server/#rcn-drone-backend","text":"This service specifically created to consumer drone realtime data and processing the attributes like altitude, velocity, location etc. Currently, the service in under development. The data will be used export in metric operators like prometheus and create dashboards.","title":"RCN Drone Backend"},{"location":"user_guide/server/#additional-features","text":"The Streamer can also be used for Computer Vision and Machine Learning can be also implemented. Users can implement CNN architecture as per the use case.","title":"Additional Features"}]}