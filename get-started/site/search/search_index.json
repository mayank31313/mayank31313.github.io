{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Control Net Official Portfolio . Introduction Welcome, I am excited to present ControlNet is a communication platform for devices like Raspberry Pi's that support python programming language. The purpose to build this platform is to connect various devices over a network(i.e private & public network). Each has a unique use-case. Control Net Architecture is divided in 3 Projects IOR Control Net Tower IOR Socket Server IOR Video Streamer Getting Started Server Setup Docker Docker is a open platform to run apps in a container and seperate those apps from the infrastructure. You can install docker as per your platform needs from here , we will also need Docker Compose which can be installed from this page . Download Docker Compose File cd ~ mkdir controlnet-docker cd controlnet-docker wget https://mayank31313.github.io/docker/full/docker-compose.yml The above command will download docker-compose file in the current directory Run servers in Docker To run containers just run the below command in the docker-compose file directory, it will pull necessary images and start docker containers. docker-compose up To stop the containers, run below command docker-compose down Client (IOR-Python) The client code is available on this github repository Setup Client For this example no external configuration is needed, all the settings are predefined. The below example will only give a use case on the controlnet platform. git clone https://github.com/mayank31313/ior-python cd ior-python/examples python3 LatencyCheck.py ../config/from.json ../config/to.json Usage config = { \"server\": \"localhost\", \"httpPort\": 5001, \"socketServer\": \"localhost\", \"tcpPort\": 8000, #\"useSSL\": True # Optional } Create Instance of IOT Client from ior_research.IOTClient import IOTClientWrapper iot = IOTClientWrpper(token=token, config = config) #Creating object for IOT Client Setting up Receive Function to do some Operation when a response is received. iot.set_on_receive(lambda x: print(x)) Last but not the least start the IOTClient iot.start() iot.join() Quick Demo","title":"Home"},{"location":"#welcome-to-control-net","text":"Official Portfolio .","title":"Welcome to Control Net"},{"location":"#introduction","text":"Welcome, I am excited to present ControlNet is a communication platform for devices like Raspberry Pi's that support python programming language. The purpose to build this platform is to connect various devices over a network(i.e private & public network). Each has a unique use-case. Control Net Architecture is divided in 3 Projects IOR Control Net Tower IOR Socket Server IOR Video Streamer","title":"Introduction"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#server","text":"","title":"Server"},{"location":"#setup-docker","text":"Docker is a open platform to run apps in a container and seperate those apps from the infrastructure. You can install docker as per your platform needs from here , we will also need Docker Compose which can be installed from this page .","title":"Setup Docker"},{"location":"#download-docker-compose-file","text":"cd ~ mkdir controlnet-docker cd controlnet-docker wget https://mayank31313.github.io/docker/full/docker-compose.yml The above command will download docker-compose file in the current directory","title":"Download Docker Compose File"},{"location":"#run-servers-in-docker","text":"To run containers just run the below command in the docker-compose file directory, it will pull necessary images and start docker containers. docker-compose up To stop the containers, run below command docker-compose down","title":"Run servers in Docker"},{"location":"#client-ior-python","text":"The client code is available on this github repository","title":"Client (IOR-Python)"},{"location":"#setup-client","text":"For this example no external configuration is needed, all the settings are predefined. The below example will only give a use case on the controlnet platform. git clone https://github.com/mayank31313/ior-python cd ior-python/examples python3 LatencyCheck.py ../config/from.json ../config/to.json","title":"Setup Client"},{"location":"#usage","text":"config = { \"server\": \"localhost\", \"httpPort\": 5001, \"socketServer\": \"localhost\", \"tcpPort\": 8000, #\"useSSL\": True # Optional }","title":"Usage"},{"location":"#create-instance-of-iot-client","text":"from ior_research.IOTClient import IOTClientWrapper iot = IOTClientWrpper(token=token, config = config) #Creating object for IOT Client","title":"Create Instance of IOT Client"},{"location":"#setting-up-receive-function-to-do-some-operation-when-a-response-is-received","text":"iot.set_on_receive(lambda x: print(x))","title":"Setting up Receive Function to do some Operation when a response is received."},{"location":"#last-but-not-the-least-start-the-iotclient","text":"iot.start() iot.join()","title":"Last but not the least start the IOTClient"},{"location":"#quick-demo","text":"","title":"Quick Demo"},{"location":"python-di/","text":"Python Dependency Injection Official Repo Introduction As the name suggest, this application is for injecting dependencies into other objects. It's much similar to Java Spring Framework. Show me the code Create a test bean class for custom dependency injection # Create a class for bean class TestBean: def __init__(self, name): self.name = name Define a bean method to return a Bean Object using @Bean. NOTE: : The bean method parameters and return type should have the class name of the dependent and return type object, to let it know which class object should be injected and returned. # Create a bean object for Autowiring @Bean() def getTestBean() -> TestBean: return TestBean(\"Test 123\") Test your dependency injection, using @Autowired. NOTE: : The autowired method parameters should have the class name of the Dependent Object, to let it know which class object should be injected. testBean = None # Autowire the dependency @Autowired() def setTestBean(bean: TestBean): global testBean print(bean) testBean = bean if __name__ == \"__main__\": app = AppInitilizer() # Create a instance for AppInitializer app.componentScan(\"test_module\") # Add package to scan for any component or bean app.run() # Call run methods to inject beans print(testBean.name) print(type(testBean)) Advance: Lookup at CNDI External yaml configurations Using cndi users can configure the application on different environemnt setting, using the rcn.profile attribute in the yaml file. Checkout the below yaml configuration rcn.profile: local mqtt: broker: localhost port: 1883 --- rcn.profile: dev mqtt: broker: dev_mqtt_adderss.com port: 11883 The above yaml has the configurations for two environment local and dev , with different configuration for mqtt brokers. Below is the code for how to use it. from cndi.env import loadEnvFromFile, getContextEnvironment # First step: set the profile, this can be set directly to environment RCN_ENVS_CONFIG.active.profile or using os package RCN_ENVS_CONFIG = 'RCN_ENVS_CONFIG' os.environ[f\"{RCN_ENVS_CONFIG}.active.profile\"] = \"local\" # Set profile to use # Load yaml file loadEnvFromFile(\"path/to/yaml\") server = getContextEnvironment(\"mqtt.broker\") # Get Property Value port = int(getContextEnvironment(\"mqtt.port\")) # Get Property Value Flask Application Let's create a flask app to get the working on CNDI in depth (well below video doesn't go that far but gives some understanding). In this example we will create a Flask app which will listen at /events. Find the repository here. NOTE: : The above app requires a mqtt broker running in background. Otherwise it will throw exception while calling connect method. Route: /event will send a timestamp to mqtt topic defined in the # Directory Structure src/ + ./beans/*/*.py -> Define beans in this modules and sub modules. + ./app.py -> Main application. + ./configurations/*.yml -> YAML files to define external configurations. Implementation of CNDI","title":"Quick Start"},{"location":"python-di/#python-dependency-injection","text":"Official Repo","title":"Python Dependency Injection"},{"location":"python-di/#introduction","text":"As the name suggest, this application is for injecting dependencies into other objects. It's much similar to Java Spring Framework.","title":"Introduction"},{"location":"python-di/#show-me-the-code","text":"Create a test bean class for custom dependency injection # Create a class for bean class TestBean: def __init__(self, name): self.name = name Define a bean method to return a Bean Object using @Bean. NOTE: : The bean method parameters and return type should have the class name of the dependent and return type object, to let it know which class object should be injected and returned. # Create a bean object for Autowiring @Bean() def getTestBean() -> TestBean: return TestBean(\"Test 123\") Test your dependency injection, using @Autowired. NOTE: : The autowired method parameters should have the class name of the Dependent Object, to let it know which class object should be injected. testBean = None # Autowire the dependency @Autowired() def setTestBean(bean: TestBean): global testBean print(bean) testBean = bean if __name__ == \"__main__\": app = AppInitilizer() # Create a instance for AppInitializer app.componentScan(\"test_module\") # Add package to scan for any component or bean app.run() # Call run methods to inject beans print(testBean.name) print(type(testBean))","title":"Show me the code"},{"location":"python-di/#advance-lookup-at-cndi","text":"","title":"Advance: Lookup at CNDI"},{"location":"python-di/#external-yaml-configurations","text":"Using cndi users can configure the application on different environemnt setting, using the rcn.profile attribute in the yaml file. Checkout the below yaml configuration rcn.profile: local mqtt: broker: localhost port: 1883 --- rcn.profile: dev mqtt: broker: dev_mqtt_adderss.com port: 11883 The above yaml has the configurations for two environment local and dev , with different configuration for mqtt brokers. Below is the code for how to use it. from cndi.env import loadEnvFromFile, getContextEnvironment # First step: set the profile, this can be set directly to environment RCN_ENVS_CONFIG.active.profile or using os package RCN_ENVS_CONFIG = 'RCN_ENVS_CONFIG' os.environ[f\"{RCN_ENVS_CONFIG}.active.profile\"] = \"local\" # Set profile to use # Load yaml file loadEnvFromFile(\"path/to/yaml\") server = getContextEnvironment(\"mqtt.broker\") # Get Property Value port = int(getContextEnvironment(\"mqtt.port\")) # Get Property Value","title":"External yaml configurations"},{"location":"python-di/#flask-application","text":"Let's create a flask app to get the working on CNDI in depth (well below video doesn't go that far but gives some understanding). In this example we will create a Flask app which will listen at /events. Find the repository here. NOTE: : The above app requires a mqtt broker running in background. Otherwise it will throw exception while calling connect method. Route: /event will send a timestamp to mqtt topic defined in the # Directory Structure src/ + ./beans/*/*.py -> Define beans in this modules and sub modules. + ./app.py -> Main application. + ./configurations/*.yml -> YAML files to define external configurations.","title":"Flask Application"},{"location":"python-di/#implementation-of-cndi","text":"","title":"Implementation of CNDI"},{"location":"python-di/binders/","text":"Binders Introduction Now lets start the advance understanding for the cndi, with the quick start guide we saw how to use Autowired annotations and initialize a global bean object. It this part we will take a look at binders and Message brokers. The binders are actually used to bind a topic to a channel, so let's take an example of a Pub/Sub Message Broker, where we have a Publisher and a Subscriber. A publisher will publish a message to 'xyz' topic, a Subscriber will subscribe to 'xyz' topic and will receive any event data publish to that topic. This is how a messaging system work in a high level overview. Now so let's say we have a message broker, a publisher and a subscriber that subscribe to a topic[s] in a normal architecture we create an instance for publisher and subscriber that connects to message broker and boom we have our messaging system app. But take a scenario where we have to deal with multiple message broker servers, (i.e. mqtt, rabbit etc) we might need to manually take care of publishers/subscribers, to resolve this problem we add a layer in the pub/sub architecture and the layer is called Binder . Message Binder and Message/Subscriber Channel To use message binder we need a message channel, a message channel can a alphabetic string that binds a topic. Syntax rcn.binders.message.mqtt.<producer|consumer>.<channelName>.destination = <topic-name> Implementation To implement Binders in the Application we need to use MessageChannel/SubscriberChannel class, MessageChannel is for producer/publisher and SubscriberChannel is for consumer/subscriber. The default configuration properties that need to be added in the yaml configuration are below rcn.binders.message.enable: Enables the DefaultMessageBinder rcn.binders.message.default: The property which describes the message broker to use currently only mqtt is supported rcn.binders.message.brokerUrl: ip address to broker rcn.binders.message.brokerPort: port of the broker to connect The yaml properties looks like: rcn: binders: message: enable: true default: mqtt brokerUrl: localhost brokerPort: 1883 Create Producer/Publisher Let's create Producer using message binder, using @Output decoration we can create a MessageChannel instance that automatically configures a channel to the topic. The only thing to produce a message is to call send method from MessageChannel @Component class Source: outputChannel1Binding: MessageChannel @Output(\"<channel-name>\") def setOutputForDefaultChannel(self, messageBinder: MqttProducerBinding): self.outputChannel1Binding = messageBinder # Create App Initializer appInitializer = AppInitializer() appInitializer.componentScan(\"\") appInitializer.run() # YAML Configuration rcn: binders: message: mqtt: producer: <channel-name>: destination: <topic> Create Subscriber/Consumer Let's create Consumer using message binder, using @Input decoration we can create a SubscriberChannel instance that automatically configures a channel to the topic. The simple consumer looks like the below code @Input(\"<channel-name>\") def setInputForDefaultChannel(message): print(message) # YAML Configuration rcn: binders: message: mqtt: consumer: <channel-name>: destination: <topic>","title":"Binders"},{"location":"python-di/binders/#binders","text":"","title":"Binders"},{"location":"python-di/binders/#introduction","text":"Now lets start the advance understanding for the cndi, with the quick start guide we saw how to use Autowired annotations and initialize a global bean object. It this part we will take a look at binders and Message brokers. The binders are actually used to bind a topic to a channel, so let's take an example of a Pub/Sub Message Broker, where we have a Publisher and a Subscriber. A publisher will publish a message to 'xyz' topic, a Subscriber will subscribe to 'xyz' topic and will receive any event data publish to that topic. This is how a messaging system work in a high level overview. Now so let's say we have a message broker, a publisher and a subscriber that subscribe to a topic[s] in a normal architecture we create an instance for publisher and subscriber that connects to message broker and boom we have our messaging system app. But take a scenario where we have to deal with multiple message broker servers, (i.e. mqtt, rabbit etc) we might need to manually take care of publishers/subscribers, to resolve this problem we add a layer in the pub/sub architecture and the layer is called Binder .","title":"Introduction"},{"location":"python-di/binders/#message-binder-and-messagesubscriber-channel","text":"To use message binder we need a message channel, a message channel can a alphabetic string that binds a topic.","title":"Message Binder and Message/Subscriber Channel"},{"location":"python-di/binders/#syntax","text":"rcn.binders.message.mqtt.<producer|consumer>.<channelName>.destination = <topic-name>","title":"Syntax"},{"location":"python-di/binders/#implementation","text":"To implement Binders in the Application we need to use MessageChannel/SubscriberChannel class, MessageChannel is for producer/publisher and SubscriberChannel is for consumer/subscriber. The default configuration properties that need to be added in the yaml configuration are below rcn.binders.message.enable: Enables the DefaultMessageBinder rcn.binders.message.default: The property which describes the message broker to use currently only mqtt is supported rcn.binders.message.brokerUrl: ip address to broker rcn.binders.message.brokerPort: port of the broker to connect The yaml properties looks like: rcn: binders: message: enable: true default: mqtt brokerUrl: localhost brokerPort: 1883","title":"Implementation"},{"location":"python-di/binders/#create-producerpublisher","text":"Let's create Producer using message binder, using @Output decoration we can create a MessageChannel instance that automatically configures a channel to the topic. The only thing to produce a message is to call send method from MessageChannel @Component class Source: outputChannel1Binding: MessageChannel @Output(\"<channel-name>\") def setOutputForDefaultChannel(self, messageBinder: MqttProducerBinding): self.outputChannel1Binding = messageBinder # Create App Initializer appInitializer = AppInitializer() appInitializer.componentScan(\"\") appInitializer.run() # YAML Configuration rcn: binders: message: mqtt: producer: <channel-name>: destination: <topic>","title":"Create Producer/Publisher"},{"location":"python-di/binders/#create-subscriberconsumer","text":"Let's create Consumer using message binder, using @Input decoration we can create a SubscriberChannel instance that automatically configures a channel to the topic. The simple consumer looks like the below code @Input(\"<channel-name>\") def setInputForDefaultChannel(message): print(message) # YAML Configuration rcn: binders: message: mqtt: consumer: <channel-name>: destination: <topic>","title":"Create Subscriber/Consumer"},{"location":"user_guide/client/","text":"Client Configuration To be known words Device A unique ior-client process, that runs on the client device. These devices are seperated by unique device code in the given user context. Connection A connection is connectivity bridge between 2 clients, managed by the IOR-SocketServer. Before the target devices connect to server, a connection has be specified on the server side to get it to work. Connection Config After cloning this repository , the directory structure is a follows ./ior-python /config /from.json /from2.json /to.json /to2.json /iorConfigs.config These are the client connection config that are required by every client that connects to the IOR-SocketServer, and are very important. These files contains server and client related configs. These files can also be downloaded through Controlnet Frontend from connections section. But by default, these configuration files can be used to Quick Start the client application. Other than that iotConfig.config file is not the connection configuration, but has some external configuration that can be used by IOR Client. Lets go In this section we will create a and understand, how the connectivity and connection works in a device. When a socket server instance is created, it also creates a default user at the server side along with some devices and connections listed below: Device 1 - Master 1 (type = Raspberry Pi) Device 2 - Slave 1 (type = Raspberry Pi) Device 3 - Master 2 (type = Raspberry Pi) Device 4 - Slave 2 (type = Raspberry Pi) Master 1,2 and Slave 1,2 are just device name given, it doesn't mean that the only master can control the slave. The communication is bidirectional. After creating a device, the devices will not pair up to each other automatically, we will need to specify a connection between those. See below image. There are 2 connections already created Connection 1: Master 1 <--> Slave 1 Connection 2: Master 2 <--> Slave 2 After creating a connection, users can download the configuration file for each connecting device from the download button. These are required and important file, as they store client configurations. In the above section , we specified json files, these are the same connection file which store client configuration. from.json = Master 1 to.json = Slave 1 from.json = Master 2 to.json = Slave 2 These json files also help socket-server to authenticate. Whats Next There is more content to add.","title":"Client"},{"location":"user_guide/client/#client-configuration","text":"","title":"Client Configuration"},{"location":"user_guide/client/#to-be-known-words","text":"","title":"To be known words"},{"location":"user_guide/client/#device","text":"A unique ior-client process, that runs on the client device. These devices are seperated by unique device code in the given user context.","title":"Device"},{"location":"user_guide/client/#connection","text":"A connection is connectivity bridge between 2 clients, managed by the IOR-SocketServer. Before the target devices connect to server, a connection has be specified on the server side to get it to work.","title":"Connection"},{"location":"user_guide/client/#connection-config","text":"After cloning this repository , the directory structure is a follows ./ior-python /config /from.json /from2.json /to.json /to2.json /iorConfigs.config These are the client connection config that are required by every client that connects to the IOR-SocketServer, and are very important. These files contains server and client related configs. These files can also be downloaded through Controlnet Frontend from connections section. But by default, these configuration files can be used to Quick Start the client application. Other than that iotConfig.config file is not the connection configuration, but has some external configuration that can be used by IOR Client.","title":"Connection Config"},{"location":"user_guide/client/#lets-go","text":"In this section we will create a and understand, how the connectivity and connection works in a device. When a socket server instance is created, it also creates a default user at the server side along with some devices and connections listed below: Device 1 - Master 1 (type = Raspberry Pi) Device 2 - Slave 1 (type = Raspberry Pi) Device 3 - Master 2 (type = Raspberry Pi) Device 4 - Slave 2 (type = Raspberry Pi) Master 1,2 and Slave 1,2 are just device name given, it doesn't mean that the only master can control the slave. The communication is bidirectional. After creating a device, the devices will not pair up to each other automatically, we will need to specify a connection between those. See below image. There are 2 connections already created Connection 1: Master 1 <--> Slave 1 Connection 2: Master 2 <--> Slave 2 After creating a connection, users can download the configuration file for each connecting device from the download button. These are required and important file, as they store client configurations. In the above section , we specified json files, these are the same connection file which store client configuration. from.json = Master 1 to.json = Slave 1 from.json = Master 2 to.json = Slave 2 These json files also help socket-server to authenticate.","title":"Lets go"},{"location":"user_guide/client/#whats-next","text":"There is more content to add.","title":"Whats Next"},{"location":"user_guide/server/","text":"Server Setup and Configuration As discuss on this page , control net depends upon 3 Application. On this page we will discuss those 3 Apps in detail. The Application Servers Control Net Tower The Server handles all the REST API requests which deals with User, Devices and Connections. The Authentication used is JWT Token Authentication. Using the server api, we can manage user, client and connections. Click here for Docker Image Socket Server (Tunnel Server) This server uses TCP Sockets to communicate. The server connects client across each other. The server is also responsible for handling the socket message. It uses AES Encryption with the Connection Key, but is partially encrypted means the messages are decrypted at the server side. But this limitation will be removed in the future builds. Click here for Docker Image Video Streamer This server is used create a Video Live Stream from a device to end user, it uses WebRTC behind the scenes. Connecting to the server requires JWT Token which can be created through Control Net Tower and the stream can be watch on the Control Net Frontend -> Sign In -> Video Streaming (On Left Drawer), for current build you can stream only 1 Device at a time. Click here for Docker Image Additional Features The Streamer can also be used for Computer Vision and Machine Learning can be also implemented. Users can implement CNN architecture as per the use case.","title":"Server"},{"location":"user_guide/server/#server-setup-and-configuration","text":"As discuss on this page , control net depends upon 3 Application. On this page we will discuss those 3 Apps in detail.","title":"Server Setup and Configuration"},{"location":"user_guide/server/#the-application-servers","text":"","title":"The Application Servers"},{"location":"user_guide/server/#control-net-tower","text":"The Server handles all the REST API requests which deals with User, Devices and Connections. The Authentication used is JWT Token Authentication. Using the server api, we can manage user, client and connections. Click here for Docker Image","title":"Control Net Tower"},{"location":"user_guide/server/#socket-server-tunnel-server","text":"This server uses TCP Sockets to communicate. The server connects client across each other. The server is also responsible for handling the socket message. It uses AES Encryption with the Connection Key, but is partially encrypted means the messages are decrypted at the server side. But this limitation will be removed in the future builds. Click here for Docker Image","title":"Socket Server (Tunnel Server)"},{"location":"user_guide/server/#video-streamer","text":"This server is used create a Video Live Stream from a device to end user, it uses WebRTC behind the scenes. Connecting to the server requires JWT Token which can be created through Control Net Tower and the stream can be watch on the Control Net Frontend -> Sign In -> Video Streaming (On Left Drawer), for current build you can stream only 1 Device at a time. Click here for Docker Image","title":"Video Streamer"},{"location":"user_guide/server/#additional-features","text":"The Streamer can also be used for Computer Vision and Machine Learning can be also implemented. Users can implement CNN architecture as per the use case.","title":"Additional Features"}]}